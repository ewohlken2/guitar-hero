{"version":3,"names":["FLAT_TO_SHARP","exports","Db","Eb","Fb","Gb","Ab","Bb","Cb","normalizePitchClass","pitchClass","normalized","charAt","toUpperCase","slice","toLowerCase","DEFAULT_MIN_CONFIDENCE","MIN_MATCH_SCORE","matchChordFromNotes","detectedPitches","chordDatabase","timestamp","minConfidence","arguments","length","undefined","confidentPitches","filter","p","confidence","detectedNotes","Set","map","note","bestMatch","chord","chordNotes","notes","score","calculateOverlapScore","size","matchCount","has"],"sources":["chordMatching.ts"],"sourcesContent":["import { Chord, DetectedPitch, DetectedChordMatch } from '../types';\n\n/**\n * Mapping of flat notes to their sharp equivalents.\n * Used to normalize pitch detection results for consistent chord matching.\n */\nexport const FLAT_TO_SHARP: Record<string, string> = {\n  Db: 'C#',\n  Eb: 'D#',\n  Fb: 'E',\n  Gb: 'F#',\n  Ab: 'G#',\n  Bb: 'A#',\n  Cb: 'B',\n};\n\n/**\n * Normalizes a pitch class name by converting flats to sharps.\n * This ensures consistent comparison between detected notes and chord databases.\n *\n * @param pitchClass - The pitch class to normalize (e.g., 'Db', 'C#', 'C')\n * @returns The normalized pitch class using sharps (e.g., 'C#', 'C#', 'C')\n */\nexport function normalizePitchClass(pitchClass: string): string {\n  // Capitalize the first letter, lowercase the rest for consistent lookup\n  const normalized =\n    pitchClass.charAt(0).toUpperCase() + pitchClass.slice(1).toLowerCase();\n\n  // Check if it's a flat note and convert to sharp\n  if (FLAT_TO_SHARP[normalized]) {\n    return FLAT_TO_SHARP[normalized];\n  }\n\n  // Return the normalized version (handles naturals and sharps)\n  return normalized;\n}\n\n/**\n * Default minimum confidence threshold for pitch detection.\n */\nconst DEFAULT_MIN_CONFIDENCE = 0.5;\n\n/**\n * Minimum overlap score required to consider a chord match valid.\n */\nconst MIN_MATCH_SCORE = 0.5;\n\n/**\n * Matches detected pitch data to the best matching chord from the database.\n *\n * The algorithm:\n * 1. Filters out low-confidence pitches\n * 2. Normalizes all detected notes (flats to sharps)\n * 3. Calculates overlap score for each chord in the database\n * 4. Returns the chord with the highest score above the threshold\n *\n * @param detectedPitches - Array of detected pitches from audio analysis\n * @param chordDatabase - Array of chords to match against\n * @param timestamp - When the detection occurred\n * @param minConfidence - Minimum confidence threshold (default: 0.5)\n * @returns The best matching chord with score, or null if no match found\n */\nexport function matchChordFromNotes(\n  detectedPitches: DetectedPitch[],\n  chordDatabase: Chord[],\n  timestamp: number,\n  minConfidence: number = DEFAULT_MIN_CONFIDENCE\n): DetectedChordMatch | null {\n  // Return null if no pitches detected\n  if (detectedPitches.length === 0) {\n    return null;\n  }\n\n  // Filter pitches by confidence threshold\n  const confidentPitches = detectedPitches.filter(\n    (p) => p.confidence >= minConfidence\n  );\n\n  // Return null if no pitches pass the confidence threshold\n  if (confidentPitches.length === 0) {\n    return null;\n  }\n\n  // Normalize detected notes and remove duplicates\n  const detectedNotes = new Set(\n    confidentPitches.map((p) => normalizePitchClass(p.note))\n  );\n\n  let bestMatch: { chord: Chord; score: number } | null = null;\n\n  for (const chord of chordDatabase) {\n    // Normalize chord notes for comparison\n    const chordNotes = new Set(chord.notes.map(normalizePitchClass));\n\n    // Calculate overlap score\n    const score = calculateOverlapScore(detectedNotes, chordNotes);\n\n    // Update best match if this chord has a higher score\n    if (score > 0 && (!bestMatch || score > bestMatch.score)) {\n      bestMatch = { chord, score };\n    }\n  }\n\n  // Return null if no match found or score too low\n  if (!bestMatch || bestMatch.score < MIN_MATCH_SCORE) {\n    return null;\n  }\n\n  return {\n    chord: bestMatch.chord,\n    score: bestMatch.score,\n    timestamp,\n  };\n}\n\n/**\n * Calculates the overlap score between detected notes and chord notes.\n *\n * Score formula: (intersection size) / (chord notes size)\n * This measures what percentage of the chord's notes were detected.\n *\n * @param detectedNotes - Set of normalized detected note names\n * @param chordNotes - Set of normalized chord note names\n * @returns Score from 0 to 1, where 1 means all chord notes were detected\n */\nfunction calculateOverlapScore(\n  detectedNotes: Set<string>,\n  chordNotes: Set<string>\n): number {\n  if (chordNotes.size === 0) {\n    return 0;\n  }\n\n  // Count how many chord notes were detected\n  let matchCount = 0;\n  for (const note of chordNotes) {\n    if (detectedNotes.has(note)) {\n      matchCount++;\n    }\n  }\n\n  return matchCount / chordNotes.size;\n}\n"],"mappings":";;;;;;AAMO,IAAMA,aAAqC,GAAAC,OAAA,CAAAD,aAAA,GAAG;EACnDE,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,GAAG;EACPC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE;AACN,CAAC;AASM,SAASC,mBAAmBA,CAACC,UAAkB,EAAU;EAE9D,IAAMC,UAAU,GACdD,UAAU,CAACE,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGH,UAAU,CAACI,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAGxE,IAAIf,aAAa,CAACW,UAAU,CAAC,EAAE;IAC7B,OAAOX,aAAa,CAACW,UAAU,CAAC;EAClC;EAGA,OAAOA,UAAU;AACnB;AAKA,IAAMK,sBAAsB,GAAG,GAAG;AAKlC,IAAMC,eAAe,GAAG,GAAG;AAiBpB,SAASC,mBAAmBA,CACjCC,eAAgC,EAChCC,aAAsB,EACtBC,SAAiB,EAEU;EAAA,IAD3BC,aAAqB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGP,sBAAsB;EAG9C,IAAIG,eAAe,CAACK,MAAM,KAAK,CAAC,EAAE;IAChC,OAAO,IAAI;EACb;EAGA,IAAME,gBAAgB,GAAGP,eAAe,CAACQ,MAAM,CAC7C,UAACC,CAAC;IAAA,OAAKA,CAAC,CAACC,UAAU,IAAIP,aAAa;EAAA,CACtC,CAAC;EAGD,IAAII,gBAAgB,CAACF,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO,IAAI;EACb;EAGA,IAAMM,aAAa,GAAG,IAAIC,GAAG,CAC3BL,gBAAgB,CAACM,GAAG,CAAC,UAACJ,CAAC;IAAA,OAAKnB,mBAAmB,CAACmB,CAAC,CAACK,IAAI,CAAC;EAAA,EACzD,CAAC;EAED,IAAIC,SAAiD,GAAG,IAAI;EAE5D,KAAK,IAAMC,KAAK,IAAIf,aAAa,EAAE;IAEjC,IAAMgB,UAAU,GAAG,IAAIL,GAAG,CAACI,KAAK,CAACE,KAAK,CAACL,GAAG,CAACvB,mBAAmB,CAAC,CAAC;IAGhE,IAAM6B,KAAK,GAAGC,qBAAqB,CAACT,aAAa,EAAEM,UAAU,CAAC;IAG9D,IAAIE,KAAK,GAAG,CAAC,KAAK,CAACJ,SAAS,IAAII,KAAK,GAAGJ,SAAS,CAACI,KAAK,CAAC,EAAE;MACxDJ,SAAS,GAAG;QAAEC,KAAK,EAALA,KAAK;QAAEG,KAAK,EAALA;MAAM,CAAC;IAC9B;EACF;EAGA,IAAI,CAACJ,SAAS,IAAIA,SAAS,CAACI,KAAK,GAAGrB,eAAe,EAAE;IACnD,OAAO,IAAI;EACb;EAEA,OAAO;IACLkB,KAAK,EAAED,SAAS,CAACC,KAAK;IACtBG,KAAK,EAAEJ,SAAS,CAACI,KAAK;IACtBjB,SAAS,EAATA;EACF,CAAC;AACH;AAYA,SAASkB,qBAAqBA,CAC5BT,aAA0B,EAC1BM,UAAuB,EACf;EACR,IAAIA,UAAU,CAACI,IAAI,KAAK,CAAC,EAAE;IACzB,OAAO,CAAC;EACV;EAGA,IAAIC,UAAU,GAAG,CAAC;EAClB,KAAK,IAAMR,IAAI,IAAIG,UAAU,EAAE;IAC7B,IAAIN,aAAa,CAACY,GAAG,CAACT,IAAI,CAAC,EAAE;MAC3BQ,UAAU,EAAE;IACd;EACF;EAEA,OAAOA,UAAU,GAAGL,UAAU,CAACI,IAAI;AACrC","ignoreList":[]}